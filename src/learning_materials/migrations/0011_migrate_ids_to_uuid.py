# Generated by Django on 2025-03-16 10:43

import uuid
from django.db import migrations, models

def populate_new_ids(apps, schema_editor):
    """
    Populate temporary UUID fields for primary keys.
    Also, do nothing for foreign keys at this point.
    """
    Cardset = apps.get_model('learning_materials', 'Cardset')
    FlashcardModel = apps.get_model('learning_materials', 'FlashcardModel')
    MultipleChoiceQuestionModel = apps.get_model('learning_materials', 'MultipleChoiceQuestionModel')
    QuestionAnswerModel = apps.get_model('learning_materials', 'QuestionAnswerModel')
    QuizModel = apps.get_model('learning_materials', 'QuizModel')
    
    # For every Cardset row, generate a new UUID and store it in new_id.
    for cardset in Cardset.objects.all():
        cardset.new_id = uuid.uuid4()
        cardset.save(update_fields=['new_id'])
    
    # For every FlashcardModel row, generate a new UUID for its own PK.
    for flashcard in FlashcardModel.objects.all():
        flashcard.new_id = uuid.uuid4()
        flashcard.save(update_fields=['new_id'])
    
    # For every MultipleChoiceQuestionModel row.
    for mcq in MultipleChoiceQuestionModel.objects.all():
        mcq.new_id = uuid.uuid4()
        mcq.save(update_fields=['new_id'])
    
    # For every QuestionAnswerModel row.
    for qa in QuestionAnswerModel.objects.all():
        qa.new_id = uuid.uuid4()
        qa.save(update_fields=['new_id'])
    
    # For every QuizModel row.
    for quiz in QuizModel.objects.all():
        quiz.new_id = uuid.uuid4()
        quiz.save(update_fields=['new_id'])

def update_flashcard_fk(apps, schema_editor):
    """
    Update the FlashcardModel's temporary foreign key.
    For each flashcard, lookup its related Cardset (via the old integer relation)
    and set flashcard.new_cardset to the new UUID stored in Cardset.new_id.
    """
    Cardset = apps.get_model('learning_materials', 'Cardset')
    FlashcardModel = apps.get_model('learning_materials', 'FlashcardModel')
    
    for flashcard in FlashcardModel.objects.all():
        # The old FK relation is still intact, so flashcard.cardset returns the Cardset instance.
        if flashcard.cardset_id:
            related_cardset = Cardset.objects.get(pk=flashcard.cardset_id)
            flashcard.new_cardset = related_cardset.new_id
            flashcard.save(update_fields=['new_cardset'])

class Migration(migrations.Migration):

    dependencies = [
        ('learning_materials', '0010_clusterelement_dimensions_clusterelement_z'),
    ]

    operations = [
        # Add temporary UUID columns for new primary keys.
        migrations.AddField(
            model_name='cardset',
            name='new_id',
            field=models.UUIDField(null=True, blank=True),
        ),
        migrations.AddField(
            model_name='flashcardmodel',
            name='new_id',
            field=models.UUIDField(null=True, blank=True),
        ),
        migrations.AddField(
            model_name='multiplechoicequestionmodel',
            name='new_id',
            field=models.UUIDField(null=True, blank=True),
        ),
        migrations.AddField(
            model_name='questionanswermodel',
            name='new_id',
            field=models.UUIDField(null=True, blank=True),
        ),
        migrations.AddField(
            model_name='quizmodel',
            name='new_id',
            field=models.UUIDField(null=True, blank=True),
        ),
        # Add a temporary field for the new foreign key in FlashcardModel.
        migrations.AddField(
            model_name='flashcardmodel',
            name='new_cardset',
            field=models.UUIDField(null=True, blank=True),
        ),
        # Populate the new_id fields.
        migrations.RunPython(populate_new_ids, reverse_code=migrations.RunPython.noop),
        # Update the temporary foreign key for FlashcardModel.
        migrations.RunPython(update_flashcard_fk, reverse_code=migrations.RunPython.noop),
    ]